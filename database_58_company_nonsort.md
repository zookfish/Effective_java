+ TCP WINDOW 理解为一个缓冲区,建立tcp链接的两方都有各自的TCP WINDOw(缓冲区)，如果接收方读取数据很慢,接收方的TCP WINDOW就会不断的减小,为0的时候就会发送警告给发送方,发送方不断的将数据发送到自己的TCP WINDOW,就会导致发送方的TCP WINDOW一直无法及时的清空,如果缓冲区的size为0的时候就会停止发送数据


+ tcp 的粘包/拆包 
	+ 粘包: 客户端发送的两端独立的数据被服务端一起接收 
	+ 拆包: 客户端发送的两段独立数据被服务端D1 + D2的一部分 --> D2的剩余部分 两次接收
	+ 解决tcp的分包问题 
		+ 消息定长 
		+ 将回车换行符作为消息的结束 
		+ 特殊的字符作为消息的结束 
		+ 消息头定义消息的长度
			+ DelimiterBasedFrameDecoder  指定分隔符解码器
			+ FixedLengthFrameDecoder  定长解码器
+ java本身的序列化  
	+ 无法跨语言 
+ 插播一段 
	+ ctrl + n 查找类 
	+ ctrl + shift + n 查找文件 
	+ 在方法里面 ctrl + shift + t 打开这个方法的测试类,如果没有可以选择创建,在测试方法里面ctrl + shift + t 跳回到该方法的实现 
	+ ctrl + e 打开最近文件 
	+ ctrl + tab 在最近的两个文件之间切换 
	+ ctrl + d 复制一行 
	+ ctrl + x 剪切一行 
	+ ctrl + delete 删除单词的后面部分  ctrl + backspace 删除单词前面部分  ctrl + y 删除行 
	+ ctrl + alt + enter 上面插入一行  shift + enter 下面插入一行 
	+ ctrl + w 快速选中 连续按会继续扩大选中区域 ctrl + shift + w 减小选区 
	+ alt + 上方向  快速将光标定位到方法 
	+ ctrl + shift + 上方向键 移动行  光标在方法上可以移动方法 
	+ alt + enter 提示用 
	+ ctrl + alt + v 命名变量

+ jvm内存解构
	+ 方法区 存放静态常量  xmpermsize
	+ 虚拟机栈  基本类型  
	+ 本地方法栈  native方法栈
	+ 方法栈  方法执行的时候进入栈表
	+ 堆    java对象  xms xmx  
	+ 非堆  直接内存（本机内存）

+ concurrentModitiedException 并发修改异常
	+ list在便利循环的时候,不能调用remove,remove一个对象的时候发生错误。remove会改变一个集合的索引

+ spring transactionManager 事物管理器实现 主要基于aop+ TrancsactionProcyFactoryBean 

+ classLoader 
	+ 根加载器
	+ ext扩展类加载器
	+ appclassloader 加载本地类

+ enum线程安全
	+ 枚举实例实际是一个静态常量,类加载的时候是线程安全

+ 数据库架构
	+ 单库体系
	+ 分组体系
		+ 主从结构  主从之间通过binlog来同步数据,读写分离
	+ 分片体系
		+ 水平切分
			+ 分库
				+ 轮询法  
				+ 范围法,定义范围落数到库 1-1kw db1 1kw-2kw db2
				+ hash取模  hash值%2 取余+ 分表+ 数据还是停留在一个数据库中.对数据库内存开销打.磁盘操作IO吃紧
		+ 垂直切分
			+ 将查询密集的,短字节字段抽离出来,一般根据业务主键切分为多张表,减少单表内存,查询性能提高

		> ***这里通过hash取模的方法有个严重的问题,我们的某台机器down了,或者我们需要新增机器的时候,会改变原有的几乎所有的分配的数据.到时候会有大量的数据迁移工作要做.业界采用一致性hash解决这个问题(通过将机器hash分配到0-232-1之间,同样取分配的key的hash也分配在该区间,按照逆时针方向找对应的服务器,找到了就将该条数据归属到其中,这样无论是减少还是增加服务器时,都会最小程度的迁移数据.其实一致性hash还有个虚拟节点会保证数据分布的均匀性.)***
		+ 分片&分组
			+ 分组解决高可用.分片解决查询数据量大问题

+ 单key业务的数据库设计
	+ 前台业务查询,用户根据login_name登录,用户查询最近购物
	+ 后台业务,运营根据各种条件限制查询数据
	+ 前台业务根据uid主键分库,查询

	+ 解决对应的非主键查询定位到库的方案
		+ 建立非主键与uid的索引表  (这会导致查询两次)
		+ 索引表改为缓存的形式      仍然需要查询缓存
		+ 设计非主键生成全局唯一uid  增加设计的难度
		+ uid中融入非主键基因      利用现有的全局唯一id+f(login_name) 生成uid,分库采用该基因来分库分表

	+ 后台业务
		+ 直接冗余一张表,与前台业务解耦,满足查询即可 

+ 一对多的业务设计 

+ 多对多业务设计
	
	+ 数据冗余