
#### 分布式事务的解决方案

+ 两阶段提交
	+ 准备阶段,协调者给参与者发起准备的消息,参与者分别要么返回失败,要么在本地执行事物(undohe redo),但不提交
	+ 协调者接收参与者消息
		+ 如果收到失败的消息.则发送回滚的消息.参与者发送回滚完成,
		+ 协调者取消事物如果收到成功的消息,则发起commit的消息,参与者发送完成,协调者完成事物
	+ 问题: 
		+ 所有参与者在等待协调者发送消息的过程中都是同步阻塞的状态
		+ 协调者发送commit宕机,会发生单点故障,有可能有一部分参与者没有收到commit的消息,即使协调者通过选举产生了新的leader,也不能确定这条事物是否已经成功执行(新的leader会收取不到一部分参与者发送确认的消息)
+ 三阶段提交
	+ 询问阶段: 协调者询问参与者的状态(是否可以执行事物)
		+ 所有参与返回ok,则进入准备状态
		+ 返回no就不用继续执行了
	+ 预提交阶段: 协调者发送预提交,参与者在本地执行事物(写redo和undo的日志),并返回确认消息
		+ 所有的参与者都ok,则等待参与者发送docommit
		+ 有失败的,参与者发送取消事物的消息(或者等待超时),参与者中断事物
	+ docommit阶段: 向所有的参与者发送提交事物,等待参与者返回ack,然后在完成事物
	+ 问题: 引入了超时的机制: 解决了宕机的问题,超时迅速释放资源


+ base模型
	+ TODO
+ CAP 理论
	+ TODO
	
+ 刚性事物
	+ 全局事物管理
+ 柔性事物
	+ 可靠消息最终一致 (异步确认)
		+ 保证消息的可靠:
			+ 主动发先发送消息给消息中间件,消息中间件落地消息到存储数据库,将该消息标志位待处理
			+ 向主动方发送存储成功或者失败,成功主动方执行业务操作,失败不执行
			+ 主动方执行业务操作之后发送执行成功或者失败的消息给消息中间件
			+ 成功,消息中间件将消息标记为待发送,失败则删除存储在数据中的消息
			+ 被动方监听待发送的消息,消费成功发送ack确认的消息给中间件
				+ 消息重复消费的问题(中间件不能正确的收到ack的确认,会导致消息中间件重复发送),被动方要实现对消息的业务处理幂等性
				+ 消息重新发送的次数限制
			+ 中间件接收到ack则删除消息
		+ 问题: 没有现成的mq支持该系统
		+ 变通: 独立的消息服务设计
			+  自建独立的消息服务子系统（在消息发送到中间件之前执行消息的可靠性控制）
			+ dubbo的refrence服务采用异步的方式来调用服务
	+ TCC型事物解决方案(两阶段提交,补偿)
		

	+ 最大努力通知型(非可靠消息,定期校对)